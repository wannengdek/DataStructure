## 第三章 线程

### 程序、进程、线程

`程序`：是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。

`进程`：是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。——生命周期 

进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域

`线程`：进程可进一步细化为线程，是一个程序内部的一条执行路径。

 若一个进程同一时间并行执行多个线程，就是支持多线程的 

线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开 销小

 一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以 访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资 源可能就会带来安全的隐患。



多个线程共享方法区、堆。自己拥有自己的虚拟机栈、程序计数器。



### 单核多核

####  单核CPU

，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程 的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费 才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以 把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时 间单元特别短，因此感觉不出来。

 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）

  一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。

####   并行与并发 

 并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。

  并发：一个CPU(采用时间片)同时执行多个任务。比如：秒杀、多个人做同一件事。



### 多线程的优点

`背景`：以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方 法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？
`多线程程序的优点`： 

1. 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 
2.  提高计算机系统CPU的利用率 
3.  改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和 修改

#### 何时需要多线程

 程序需要同时执行两个或多个任务。
 程序需要实现一些需要等待的任务时，如用户输入、文件读写
操作、网络操作、搜索等。
 需要一些后台运行的程序时。



### 线程的创建和使用

Java语言的JVM允许程序运行多个线程，它通过`java.lang.Thread `类来体现。
Thread类的特性 

每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常 把run()方法的主体称为线程体

 通过该Thread对象的`start()`方法来启动这个线程，而非直接调用`run()`



####  测试Thread中的常用方法：

1. start():启动当前线程；调用当前线程的run()

2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中

3. currentThread():静态方法，返回执行当前代码的线程

4. getName():获取当前线程的名字

5. setName():设置当前线程的名字

6. yield():释放当前cpu的执行权

7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才

结束阻塞状态。

8. stop():已过时。当执行此方法时，强制结束当前线程。

9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内*，当前线程是阻塞状态。

10. isAlive():判断当前线程是否存活

    

### 创建多线程方式一 ：继承Thread类



```java

//1. 创建一个继承于Thread类的子类
class MyThread extends Thread {
    //2. 重写Thread类的run()
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i);
            }
        }
    }
}


public class ThreadTest {
    public static void main(String[] args) {
        //3. 创建Thread类的子类的对象
        MyThread t1 = new MyThread();

        //4.通过此对象调用start():①启动当前线程 ② 调用当前线程的run()
        t1.start();
        //问题一：我们不能通过直接调用run()的方式启动线程。
//        t1.run();

        //问题二：再启动一个线程，遍历100以内的偶数。不可以还让已经start()的线程去执行。会报IllegalThreadStateException
//        t1.start();
        //我们需要重新创建一个线程的对象
        MyThread t2 = new MyThread();
        t2.start();


        //如下操作仍然是在main线程中执行的。
        for (int i = 0; i < 100; i++) {
            if(i % 2 == 0){
                System.out.println(Thread.currentThread().getName() + ":" + i + "***********main()************");
            }
        }
    }
}
```

start 方法只可以执行一次，不可以还让已经start()的线程去执行。会报IllegalThreadStateException





####  线程的优先级：

1.

MAX_PRIORITY：10

MIN _PRIORITY：1

NORM_PRIORITY：5  -->默认优先级

2.如何获取和设置当前线程的优先级：

getPriority():获取线程的优先级

setPriority(int p):设置线程的优先级


说明：**高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况*下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。**



### 线程调度、线程分类

![1565349069445](第三章 线程.assets/1565349069445.png)

**Java中的线程分为两类：一种是守护线程，一种是用户线程。**

  它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 

 守护线程是用来服务用户线程的，通过在start()方法前调用 thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 

 Java垃圾回收就是一个典型的守护线程。 

 若JVM中都是守护线程，当前JVM将退出。 

 形象理解：兔死狗烹，鸟尽弓



